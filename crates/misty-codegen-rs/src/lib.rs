mod error;
mod options;
mod types;
mod util;

pub use error::RustCodeGeneratorError;
pub use options::RustCodeGeneratorOptions;

use heck::{ToPascalCase, ToShoutySnakeCase};
use misty_ast::{ContainerType, DataType, Definition, Interface, Schema};
use misty_core::codegen::CodeGenerator;
use misty_parser::Workspace;
use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use std::path::Path;

#[derive(Default, Clone, Copy)]
pub struct RustCodeGenerator;

impl CodeGenerator for RustCodeGenerator {
    type Error = RustCodeGeneratorError;
    type Options = RustCodeGeneratorOptions;

    #[tracing::instrument(skip(self, options, workspace, output_dir))]
    fn generate(
        &self,
        options: &Self::Options,
        workspace: &Workspace,
        output_dir: &Path,
    ) -> Result<(), Self::Error> {
        // Iterate over all modules available in the workspace and generate Rust code for them.
        for (module_name, file) in workspace.package_local_modules() {
            // Generate the Rust code for the module.
            let tokens = self.generate_module_content(module_name, &file.definitions);
            println!("{}", tokens);
        }
        todo!()
    }
}

impl RustCodeGenerator {
    fn generate_module_content(
        &self,
        module_name: &str,
        definitions: &[Definition],
    ) -> TokenStream {
        // Standard module header without `use` statements because we use absolute module paths.
        let header_attrs = quote! {
            #![doc = "Auto-generated by Misty. DO NOT EDIT!"]
            #![cfg_attr(rustfmt, rustfmt::skip)]
            #![allow(warnings)]
            #![allow(clippy::all)]
        };

        // Generate the code for all the definitions in the module.
        let definitions_tokens = definitions
            .iter()
            .map(|definition| self.generate_definition(module_name, definition))
            .collect::<Vec<_>>();

        quote! {
            #header_attrs
            #(#definitions_tokens)*
        }
    }

    /// Generates Rust code for a single definition.
    fn generate_definition(&self, module_name: &str, definition: &Definition) -> TokenStream {
        match definition {
            Definition::Schema(schema) => self.generate_schema(module_name, schema),
            Definition::Enum(misty_enum) => self.generate_enum(module_name, misty_enum),
            Definition::Interface(interface) => self.generate_interface(module_name, interface),
        }
    }

    /// Generates Rust code for a schema.
    fn generate_schema(&self, module_name: &str, schema: &Schema) -> TokenStream {
        // Hash builder for the discriminator of this struct.
        let mut discriminator_hash = blake3::Hasher::new();
        discriminator_hash.update(module_name.as_bytes());

        // Build the identifier for the struct.
        let name = format_ident!("{}", schema.name);
        discriminator_hash.update(name.to_string().as_bytes());

        // Build a list of all fields of the struct.
        let fields = schema
            .fields
            .iter()
            .map(|field| {
                let field_name = format_ident!("{}", field.name);
                let field_type = self.generate_data_type(&field.field_type);
                quote! { pub #field_name: #field_type, }
            })
            .collect::<Vec<_>>();
        fields.iter().for_each(|field| {
            discriminator_hash.update(field.to_string().as_bytes());
        });

        // Get the hash and output that as a discriminator const.
        let discriminator_ident = format_ident!("SCHEMA_{}_ID", schema.name.to_shouty_snake_case());
        let discriminator = util::generate_discriminator(discriminator_hash.finalize());

        // Build the final struct definition.
        quote! {
            pub const #discriminator_ident: &[u8; 32] = #discriminator;

            #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
            pub struct #name {
                #(#fields)*
            }
        }
    }

    /// Generates Rust code for an enum.
    fn generate_enum(&self, module_name: &str, misty_enum: &misty_ast::Enum) -> TokenStream {
        // Hash builder for the discriminator of this enum.
        let mut discriminator_hash = blake3::Hasher::new();
        discriminator_hash.update(module_name.as_bytes());

        // Build the identifier for the enum.
        let name = format_ident!("{}", misty_enum.name);
        discriminator_hash.update(name.to_string().as_bytes());

        // Get the idents for all variants of the enum.
        let variants = misty_enum
            .variants
            .iter()
            .map(|variant| format_ident!("{}", variant.to_pascal_case()))
            .collect::<Vec<_>>();
        variants.iter().for_each(|variant| {
            discriminator_hash.update(variant.to_string().as_bytes());
        });

        // Get the hash and output that as a discriminator const.
        let discriminator_ident =
            format_ident!("ENUM_{}_ID", misty_enum.name.to_shouty_snake_case());
        let discriminator = util::generate_discriminator(discriminator_hash.finalize());

        // Build the final enum definition.
        quote! {
            pub const #discriminator_ident: &[u8; 32] = #discriminator;

            #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, serde::Serialize, serde::Deserialize)]
            pub enum #name {
                #(#variants),*
            }
        }
    }

    /// Generates Rust code for an interface.
    fn generate_interface(&self, module_name: &str, interface: &Interface) -> TokenStream {
        // Generate the interface trait definition.
        let interface_trait = self.generate_interface_trait(module_name, interface);

        // Generate a MistyService implementation for the interface.
        let mist_service_impl = self.generate_service_impl(module_name, interface);

        // Generate a MistClient implementation for the interface.
        let mist_client_impl = self.generate_client_impl(module_name, interface);

        quote! {
            #interface_trait
            #mist_service_impl
            #mist_client_impl
        }
    }

    /// Generates Rust code for the trait that defines the interface.
    fn generate_interface_trait(&self, module_name: &str, interface: &Interface) -> TokenStream {
        quote! {}
    }

    /// Generates Rust code that implements the [MistyService] trait for the interface.
    fn generate_service_impl(&self, module_name: &str, interface: &Interface) -> TokenStream {
        quote! {}
    }

    /// Generates Rust code that creates a client for the interface.
    fn generate_client_impl(&self, module_name: &str, interface: &Interface) -> TokenStream {
        quote! {}
    }

    /// Converts a Misty data type to its Rust representation.
    fn generate_data_type(&self, data_type: &DataType) -> TokenStream {
        match data_type {
            DataType::Primitive(primitive) => self.primitive_to_rust(primitive),
            DataType::UserType(user_type) => self.user_type_to_rust(user_type),
            DataType::Container(container_type, inner) => {
                let inner_tokens = self.generate_data_type(inner);
                match container_type {
                    ContainerType::Vec => quote! { Vec<#inner_tokens> },
                    ContainerType::Option => quote! { Option<#inner_tokens> },
                }
            }
        }
    }

    /// Converts a primitive type to its Rust representation.
    fn primitive_to_rust(&self, primitive: &str) -> TokenStream {
        match primitive {
            "u8" => quote! { u8 },
            "u16" => quote! { u16 },
            "u32" => quote! { u32 },
            "u64" => quote! { u64 },
            "u128" => quote! { u128 },
            "i8" => quote! { i8 },
            "i16" => quote! { i16 },
            "i32" => quote! { i32 },
            "i64" => quote! { i64 },
            "i128" => quote! { i128 },
            "f32" => quote! { f32 },
            "f64" => quote! { f64 },
            "bool" => quote! { bool },
            "str" => quote! { String },
            _ => quote! { compile_error!("Unknown primitive") },
        }
    }

    /// Converts a user-defined type to its Rust representation.
    fn user_type_to_rust(&self, user_type: &str) -> TokenStream {
        // If the type contains a dot, then it is either `package-local` or `package-remote`.
        // Otherwise, it is `module-local`.
        if user_type.contains('.') {
            // Extract each segment of the type.
            let parts = user_type.split('.').collect::<Vec<_>>();

            // Build the module definition. We currently only work with `package-local` and
            // `module-local` types. So using `crate` is fine.
            let mut module_segments = vec![quote! { crate }];
            for part in parts {
                let ident = format_ident!("{part}");
                module_segments.push(quote! { #ident });
            }

            // Join everything together and return the final type.
            quote! { #(#module_segments)::* }
        } else {
            // If the type is `module-local`, then we can just use the identifier directly.
            let ident = format_ident!("{user_type}");
            quote! { #ident }
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::{RustCodeGenerator, RustCodeGeneratorOptions};
    use misty_core::codegen::CodeGenerator;

    #[test]
    fn it_works() {
        let source = r#"
        schema MySchema { name: str; age: u8; }
        enum MyEnum { VARIANT_A, VARIANT_B }
        "#;
        let source_ast = misty_parser::parse(source).unwrap();

        let mut workspace = misty_parser::Workspace::new();
        workspace.add_local_module("main", source_ast);
        workspace.validate().unwrap();

        let generator = RustCodeGenerator;
        let options = RustCodeGeneratorOptions::default();
        generator
            .generate(&options, &workspace, std::path::Path::new("."))
            .unwrap();

        assert!(false);
    }
}
